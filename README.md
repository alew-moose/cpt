## 1. Удалить дубли из хеша

```
sub delete_duplicate_values($hash) {
    my %seen;
    while (my ($key, $val) = each %$hash) {
        if ($seen{$val}) {
            delete $hash->{$key};
        } else {
            $seen{$val} = 1;
        }
    }
}
```

## 3. Типы объявления переменных
`my` объявляет лексическую переменную, при каждом вызове func создаётся новая переменная, выведется `A=1` 10 раз

`our` объявляет лексический alias для глобальной переменной в текущем пакете. Выведется
```
A=1
A=2
A=3
A=4
A=5
A=6
A=7
A=8
A=9
A=10
```

`local` модифицирует глобальную переменную в рамках текущего блока (функции `func`, в данном случае). Функция не будет работать если используется `use strict 'vars'`. Выведется `A=1` 10 раз

`state` объявляет переменную с лексической областью видимости, которая инициализируется один раз и сохраняет своё значение между вызовами функции. Выведется
```
A=1
A=2
A=3
A=4
A=5
A=6
A=7
A=8
A=9
A=10
```

```
sub func {
    my $var if 0;
    $var++;
    say "A=$var";
}
```
начиная с v5.30 эта конструкция больше не поддерживается. Это был баг, в результате которого лексическая переменная не очищалась при выходе из области видимости, и выводилось бы
```
A=1
A=2
A=3
A=4
A=5
A=6
A=7
A=8
A=9
A=10
```
Согласно `perlsyn`, такие конструкции использовать нельзя: "The behaviour of a my, state, or our modified with a statement modifier conditional or loop construct (for example, my $x if ...) is undefined". Если нужно, чтобы переменная сохраняла значение между вызовами, нужно использовать `state`.


## 4. Обработка данных из БД
Можно обработать данные порционно
```
  select id, data
  from table
  where id > ?
  order by id
  limit ?
```

```
my $last_id = 0; # или NULL UUID, если для id используется UUID
my $limit = 10000; # размер порции данных

while (1) {
  my $rows = get_data($last_id, $limit);
  last unless @$rows;
  process_data($rows);
  $last_id = $rows[-1]{id};
}

```
При этом могут возникнуть проблемы: данные в обработанных записях могут измениться во время обработки, обработанные записи могут удалиться, если для id используется UUID, в процессе обработки могут добавиться записи, которые не будут обработаны, если UUID новой записи < last_id. Можно всю обработку произвести в рамках одной транзакции, но это может привести к проблемам производительности базы. Если есть реплика базы, может иметь смысл производить подобные операции на ней

## 5. Поправить утечку памяти
да, можно применить слабые ссылки
```
while (1) {
  my $a = {b => {}};
  $a->{b}{a} = $a;
  weaken $a->{b}{a};
}
```
При работе со слабыми ссылками нужно вызывать weaken на ссылке в переменной, которая выйдет из области видимости первой. Таким образом, более долгоживущая переменная будет содержать ссылку, пока не выйдет из области видимости
```
my $a = {};
{
    my $b = {a => $a};
    $a->{b} = $b;
    weaken $b->{a}; # а не weaken $a->{b}
}
# здесь в $a->{b} всё ещё есть ссылка на $b
```

## 6. Работа с памятью
Память утекает, потому что функция ссылается на `$a`. Нужно использовать слабую ссылку
```
while (1) {
    my $a = {};
    $a->{func} = sub {
        $a->{cnt}++;
    };
    weaken $a->{func};
}
```

## 7. HTTP запрос

## 8. Наследование
Будут вызваны функции DD::func, BB::func, AA::func. Чтобы были вызваны функции во всех классах иерархии, можно использовать mro::next::method:
```
package AA;
sub func { print "AA\n" }

package BB;
use parent -norequire, 'AA';
sub func { print "BB\n"; shift->next::method(@_); }

package CC;
use parent -norequire, 'AA';
sub func { print "CC\n"; shift->next::method(@_); }

package DD;
use parent -norequire, qw/BB CC/;
sub func { print "DD\n"; shift->next::method(@_); }

package main;
use mro;
DD->func;
```
тогда будут вызваны функции DD::func, BB::func, CC::func, AA::func.
